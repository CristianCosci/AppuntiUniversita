\section{Obbiettivo}

L'obiettivo di questa esercitazione \`{e}  quello di realizzare un cluster di 2 nodi nel quale si dovr√† avere \textit{Pacemaker} come Cluster Resource Manager (\textit{CRM}), \textit{Corosync} come \textit{Cluster Engine}, \textit{Apache} come \textit{Web Server} e \textit{DRBD} per creare una risorsa replicata in tutti i nodi del cluster (\textit{Distributed Replicated Storage System}).

\section{Ambiente di Lavoro}

Questa esercitazione \`{e} stata svolta all'interno del seguente ambiente di lavoro:

\begin{itemize}
	\item \textbf{Hardware}: 
		\begin{itemize}
			\item \textbf{CPU}: AMD Ryzen 9 5900x
			\item \textbf{RAM}: 32 GB DDR4 @3200 MHz
		\end{itemize}
	\item \textbf{Software}:
		\begin{itemize}
			\item \textbf{Host OS:} Arch Linux
			\item \textbf{Guest OS}: Fedora 34 Server
			\item \textbf{Virtualization Software}: VirtualBox 6.1
		\end{itemize}
\end{itemize}

\section{Configurazione Macchine}

Per questa esercitazione sono necessarie 2 macchine virtuali che saranno i due nodi del nostro cluster. Ogni macchina \`{e} stata configurata come segue:

\begin{itemize}
	\item \textbf{Cores:} 5 Core
	\item \textbf{RAM:} 5GB
	\item \textbf{Dischi di archiviazione:}
		\begin{itemize}
			\item Disco Principale da 25 GB
			\item Disco per risorsa condivisa da 1 GB
		\end{itemize}
	\item \textbf{Scheda di Rete:} Scheda di rete con Bridge
\end{itemize}

\`{E} consigliato configurare una sola macchina, installare e configurare il sistema operativo e i software necessari, per poi utilizzare la funzione 'Clona' di VirtualBox per generare una copia identica senza dover ripetere tali operazioni nuovamente. Durante la fase di clonazione della macchina \`{e} necessario selezionare l'opzione "Generare nuovi Mac Address per ogni Network Adapter" come policy per la gestione dei Mac Address.

\begin{center}
	\includegraphics[scale=0.4]{screens/vb_macpolicy.png}
\end{center}
 
\section{Configurazione Software}

%% forse ci posso aggiungere una breve introduzione ...

\subsection{Sistema Operativo}

Qui ci va uno speghino un po dettagliato di come ho installato il sistema operativo. Piu immagini che altro, deve essere una brevissima guida.

Notare come di default il servizio sshd e' attivo e ho utilizzato ssh per connettermi e modificare le macchine

\subsection{Software Necessario}

Appena ho terminato la fase precendete ho provveduto ad aggiornare il sistema con il seguente comando, per evitare probelmi di compatibilit\`{a} e software obsoleto:

\begin{lstlisting}[style=cmd]
 sudo dnf -y upgrade
\end{lstlisting} 
\ \\
Poi ho installato i pacchetti necessari (\textit{Pacemaker}, \textit{Corosync}, \textit{Apache} e \textit{DRBD}) con: 

\begin{lstlisting}[style=cmd]
 sudo dnf -y install pacemaker corosync pcs
 sudo dnf -y install drbd-pacemaker drbd-udev
 sudo dnf -y install httpd
 sudo dnf -y install iptables-services
\end{lstlisting} 

\subsection{IP}

Per questa tipologia di esercitazione \`{e} buona norma assegnare IP statici alle macchine, ma nel mio caso non \`{e} stato necessario in quanto ho configurato il dhcp all'interno del mio router in modo da assegnare sempre lo stesso IP ai vari dispositivi della rete (dhcp statico).\\ %% ricontrollare affermazione di dhcp statico
Riporto per chiarezza la procedura per assegnare un IP statico all'interno di Fedora.

\begin{lstlisting}[style=cmd]
 sudo nmcli connection modify enp0s3 IPv4.address <ip>/24
 sudo nmcli connection modify enp0s3 IPv4.gateway <gateway>
 sudo nmcli connection modify enp0s3 IPv4.dns 8.8.8.8
 sudo nmcli connection modify enp0s3 IPv4.method manual
\end{lstlisting}
\ \\
Con il primo comando andiamo ad impostare l'ip della nostra macchina, \`{e} importate notare che bisogna sostituire \lstinline[style=cmd]|<ip>| con l'ip che vogliamo assegnare: e.g \lstinline[style=cmd]|192.168.178.32|.\\
Con il secondo configureremo l'indirizzo del gateway ed anche qui dobbiamo rimpiazzare \lstinline[style=cmd]|<gateway>| con il corretto ip: e.g. \lstinline[style=cmd]|192.168.178.1|.\\
\ \\
Per rendere effettive le modifiche basta riavviare il sistema.\\
Si pu\`{o} controllare il successo di questa operazione analizzando l'output del comando \lstinline[style=cmd]|route -n|, se restituisce qualcosa vuol dire che il tutto \`{e} andato a buon fine.

\subsection{hosts \& hostname}
\label{sec:hosts}

Ho modificato il file \lstinline[style=cmd]|/etc/hostname| definendo un nome diverso per ogni macchina dato che il mio router, tramite un servizio dns, mi permette di accedere alle macchine senza utilizzare il loro ip ma tramite il loro nome.

\begin{itemize}
	\item Nome Macchina 1: fedoraman
	\item Nome Macchina 2: fedoragirl
\end{itemize}
\ \\
In entrambe le macchine, alla fine del file \lstinline[style=cmd]|/etc/hosts| ho aggiunto le seguenti righe per facilitare poi la configurazione degli altri servizi (sostituendo \lstinline[style=cmd]|<ip macchina 1>| e \lstinline[style=cmd]|<ip macchina 2>| con i relativi ip):

\begin{lstlisting}[style=cmd]
 <ip macchina 1> Fedoraman
 <ip macchina 2> Fedoragirl
\end{lstlisting}

\subsection{Firewall}

Per evitare problemi di comunicazione tra le varie macchine ho deciso di disabilitare il firewall:

\begin{lstlisting}[style=cmd]
 sudo systemctl stop firewalld
 sudo systemctl disable firewalld
\end{lstlisting}

\subsection{PCSD}
\label{sec:pcsd}
\textit{le operazioni di questa sezione vanno eseguite in entrambe le macchine }\\
\ \\
Per prima cosa ho cambiato la password dell'utente \lstinline[style=cmd]|hacluster| in quanto servir\`{a} per l'autenticazione dei vari nodi in alcuni passaggi successivi:

\begin{lstlisting}[style=cmd]
 sudo passwd hacluster
\end{lstlisting}
\ \\
Successivamente ho abilitato il servizio e l'ho avviato con:

\begin{lstlisting}[style=cmd]
 sudo systemctl enable pcsd
 sudo systemctl start pcsd
\end{lstlisting}

\subsection{Corosync}

In entrambe le macchine ho provveduto alla configurazione di \lstinline[style=cmd]|corosync| andando a popolare il file \lstinline[style=cmd]|/etc/corosync/corosync.conf| con il seguente contenuto:

\begin{lstlisting}[style=cmd]
 totem {
   version: 2
   cluster_name: ExampleCluster
   transport: knet
   crypto_cipher: aes256
   crypto_hash: sha256
 }

 nodelist {
   node {
      ring0_addr: Fedoraman
      name: node1
      nodeid: 1
   }
	
   node {
      ring0_addr: Fedoragirl
      name: node2
      nodeid: 2
  }
 }

 quorum {
   provider: corosync_votequorum
   two_node: 1
 }

 logging {
   to_logfile: yes
   logfile: /var/log/cluster/corosync.log
   to_syslog: yes
   timestamp: on
 }
\end{lstlisting}
\ \\
Nella sezione \lstinline[style=cmd]|totem| possiamo impostare il nome del cluster andando a modificare l'attributo \lstinline[style=cmd]|cluster_name|. La sezione \lstinline[style=cmd]|nodelist| conterr\`{a} l'elenco di tutti i nodi del cluster, per ogni nodo dobbiamo aggiungere la sottosezione \lstinline[style=cmd]|node{}| con gli attributi:

\begin{itemize}
	\item \lstinline[style=cmd]|ring0_addr|: indica l'indirizzo del nodo, nel mio caso \`{e} \lstinline[style=cmd]|Fedoraman| per via della configurazione in \autoref{sec:hosts}
	\item \lstinline[style=cmd]|name|: il nome da assegnare al nodo
	\item \lstinline[style=cmd]|nodeid|: un numero progressivo che identifica il nodo
\end{itemize}

\subsection{Autenticazione dei Nodi}

Per ogni macchina ho eseguito questi comandi per autenticare ogni nodo del cluster:

\begin{lstlisting}[style=cmd]
 sudo pcs client local-auth -u hacluster
 sudo pcs cluster auth -u hacluster
\end{lstlisting}
\ \\
Verr\`{a} chiesta una password per l'autenticazione e dovremmo utilizzare quella impostata in \autoref{sec:pcsd}

\subsection{AAA}

Prova di codice/output

\begin{lstlisting}[style=cmd]
:: There are 12 members in group texlive-most:
:: Repository extra
1) texlive-bibtexextra  2) texlive-core  3) texlive-fontsextra
4) texlive-formatsextra  5) texlive-games  6) texlive-humanities
7) texlive-latexextra  8) texlive-music  9) texlive-pictures
10) texlive-pstricks  11) texlive-publishers  12) texlive-science

Enter a selection (default=all): 
warning: texlive-core-2021.58710-2 is up to date -- reinstalling
resolving dependencies...
looking for conflicting packages...

Packages (13) perl-file-which-1.24-2  texlive-bibtexextra-2021.58697-1
texlive-core-2021.58710-2  texlive-fontsextra-2021.58704-1
texlive-formatsextra-2021.57972-1  texlive-games-2021.56833-1
texlive-humanities-2021.58589-1  texlive-latexextra-2021.58668-2
texlive-music-2021.58331-1  texlive-pictures-2021.58558-1
texlive-pstricks-2021.58293-1  texlive-publishers-2021.58683-1
texlive-science-2021.58667-1

Total Download Size:    629.40 MiB
Total Installed Size:  2116.49 MiB
Net Upgrade Size:      1728.35 MiB

:: Proceed with installation? [Y/n] 

\end{lstlisting}

\subsection{Parte 3}

\begin{lstlisting}[style=output]
:: There are 12 members in group texlive-most:
:: Repository extra
1) texlive-bibtexextra  2) texlive-core  3) texlive-fontsextra
4) texlive-formatsextra  5) texlive-games  6) texlive-humanities
7) texlive-latexextra  8) texlive-music  9) texlive-pictures
10) texlive-pstricks  11) texlive-publishers  12) texlive-science

Enter a selection (default=all): 
warning: texlive-core-2021.58710-2 is up to date -- reinstalling
resolving dependencies...
looking for conflicting packages...

Packages (13) perl-file-which-1.24-2  texlive-bibtexextra-2021.58697-1
texlive-core-2021.58710-2  texlive-fontsextra-2021.58704-1
texlive-formatsextra-2021.57972-1  texlive-games-2021.56833-1
texlive-humanities-2021.58589-1  texlive-latexextra-2021.58668-2
texlive-music-2021.58331-1  texlive-pictures-2021.58558-1
texlive-pstricks-2021.58293-1  texlive-publishers-2021.58683-1
texlive-science-2021.58667-1

Total Download Size:    629.40 MiB
Total Installed Size:  2116.49 MiB
Net Upgrade Size:      1728.35 MiB

:: Proceed with installation? [Y/n] 
\end{lstlisting}